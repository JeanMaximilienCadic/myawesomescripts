#!/bin/bash
#
# A script to manage EC2 instances: list, start, stop, force-stop, switch types, update SSH config, and show status.
#
# Usage: ./manage-ec2.sh {list|start|stop|force-stop|switch <gpu|cpu>|update-ssh|status}

# --- Configuration ---
# Check required AWS environment variables
if [ -z "$AWS_DEFAULT_REGION" ] && [ -z "$AWS_REGION" ]; then
    echo "âŒ Error: AWS region not configured"
    echo "   Please set AWS_DEFAULT_REGION or AWS_REGION environment variable"
    echo "   Example: export AWS_DEFAULT_REGION=ap-northeast-1"
    exit 1
fi

if [ -z "$AWS_PROFILE" ] && [ -z "$AWS_ACCESS_KEY_ID" ]; then
    echo "âŒ Error: AWS credentials not configured"
    echo "   Please set AWS_PROFILE or AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY"
    echo "   Example: export AWS_PROFILE=your-profile-name"
    exit 1
fi

# The 'Name' tag of the EC2 instance you want to manage (required for most commands except 'list')
INSTANCE_NAME="${INSTANCE_NAME:-}"

SSH_CONFIG_FILE="$HOME/.ssh/config"

# --- Instance Type Configuration ---
GPU_INSTANCE_TYPE="g4dn.4xlarge"
CPU_INSTANCE_TYPE="m6i.2xlarge" # 8 vCPUs, 32 GiB RAM

# --- SSM Tunnel Configuration ---
# These can be overridden via environment variables
INTERNAL_PORT="${INTERNAL_PORT:-18080}"  # Internal port for SSM (localhost only)
LOCAL_PORT="${LOCAL_PORT:-8080}"          # External port exposed via socat
REMOTE_PORT="${REMOTE_PORT:-80}"          # Remote service port

# --- Colors for output ---
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Function to display the instance's current deployment info ---
show_status() {
    echo -e "${YELLOW}Fetching deployment status for instance: ${INSTANCE_NAME}...${NC}"
    INSTANCE_INFO=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" --query "Reservations[0].Instances[0].{ID:InstanceId, Type:InstanceType, State:State.Name, PublicIP:PublicIpAddress, PrivateIP:PrivateIpAddress}" --output json)
    if [ -z "$INSTANCE_INFO" ] || [ "$INSTANCE_INFO" == "null" ]; then
        echo -e "${RED}Error: Instance '${INSTANCE_NAME}' not found.${NC}"; exit 1; fi
    ID=$(echo "$INSTANCE_INFO" | jq -r .ID); TYPE=$(echo "$INSTANCE_INFO" | jq -r .Type); STATE=$(echo "$INSTANCE_INFO" | jq -r .State)
    PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIP // "N/A"'); PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.PrivateIP // "N/A"')
    STATE_COLOR=$YELLOW; if [ "$STATE" == "running" ]; then STATE_COLOR=$GREEN; elif [ "$STATE" == "stopped" ]; then STATE_COLOR=$RED; fi
    echo -e "-------------------------------------\n  Instance Name:  ${GREEN}${INSTANCE_NAME}${NC}\n  Instance ID:    ${ID}\n  Instance Type:  ${TYPE}\n  State:          ${STATE_COLOR}${STATE}${NC}\n  Private IP:     ${PRIVATE_IP}\n  Public IP:      ${PUBLIC_IP}\n-------------------------------------"
}

# --- Function to list all instances with status and open ports ---
list_instances() {
    echo -e "${YELLOW}Fetching all EC2 instances...${NC}"

    # Get all instances as JSON
    INSTANCES_JSON=$(aws ec2 describe-instances \
        --query "Reservations[].Instances[].{ID:InstanceId, Name:Tags[?Key=='Name']|[0].Value, Type:InstanceType, State:State.Name, PrivateIP:PrivateIpAddress, PublicIP:PublicIpAddress, SGs:SecurityGroups[].GroupId}" \
        --output json)

    if [ -z "$INSTANCES_JSON" ] || [ "$INSTANCES_JSON" == "[]" ]; then
        echo -e "${RED}No EC2 instances found.${NC}"
        return
    fi

    # Collect all unique security group IDs
    ALL_SG_IDS=$(echo "$INSTANCES_JSON" | jq -r '.[].SGs[]' | sort -u)

    # Fetch all security group rules in one call
    if [ -n "$ALL_SG_IDS" ]; then
        SG_RULES_JSON=$(aws ec2 describe-security-groups \
            --group-ids $ALL_SG_IDS \
            --query "SecurityGroups[].{GroupId:GroupId, Rules:IpPermissions}" \
            --output json 2>/dev/null || echo "[]")
    else
        SG_RULES_JSON="[]"
    fi

    # Build a lookup: sg-id -> ports summary
    SG_PORTS_MAP=$(echo "$SG_RULES_JSON" | jq -r '
        .[] | .GroupId as $gid |
        [.Rules[] |
            if .FromPort == .ToPort then
                (.FromPort | tostring)
            elif .FromPort != null then
                "\(.FromPort)-\(.ToPort)"
            else
                "all"
            end
        ] | unique | join(",") | "\($gid)=\(.)"
    ')

    # Fetch SSM agent status for all instances
    SSM_INFO=$(aws ssm describe-instance-information \
        --query "InstanceInformationList[].{ID:InstanceId, Status:PingStatus}" \
        --output json 2>/dev/null || echo "[]")

    # Build a lookup: instance-id -> SSM ping status
    SSM_STATUS_MAP=$(echo "$SSM_INFO" | jq -r '.[] | "\(.ID)=\(.Status)"')

    # Detect active SSM tunnels by parsing session-manager-plugin processes
    # Format: instance-id=local_port|remote_host|status
    TUNNEL_MAP=$(ps aux 2>/dev/null | grep -o 'session-manager-plugin.*' | while read -r line; do
        # Extract instance ID from the JSON payload
        INST_ID=$(echo "$line" | grep -oP '"Target"\s*:\s*"\K[^"]+' 2>/dev/null || true)
        # Extract local port from parameters
        LOCAL_P=$(echo "$line" | grep -oP '"localPortNumber"\s*:\s*\["\K[^"]+' 2>/dev/null || true)
        # Extract remote host
        REMOTE_H=$(echo "$line" | grep -oP '"host"\s*:\s*\["\K[^"]+' 2>/dev/null || true)
        # Extract remote port
        REMOTE_P=$(echo "$line" | grep -oP '"portNumber"\s*:\s*\["\K[^"]+' 2>/dev/null || true)

        if [ -n "$INST_ID" ] && [ -n "$LOCAL_P" ]; then
            # Test if tunnel is responsive (quick check)
            if nc -z -w1 localhost "$LOCAL_P" 2>/dev/null; then
                # Check if socat relay exists for this port
                SOCAT_PORT=$(ps aux 2>/dev/null | grep -oP "socat.*TCP-LISTEN:\K[0-9]+" | head -1)
                if [ -n "$SOCAT_PORT" ]; then
                    STATUS="ok:${SOCAT_PORT}"
                else
                    STATUS="ok"
                fi
            else
                STATUS="down"
            fi
            # Shorten remote host for display
            SHORT_HOST=$(echo "$REMOTE_H" | sed 's/\.internal\.yoii\.jp//' | sed 's/\.ml$//' | cut -c1-15)
            echo "${INST_ID}=${LOCAL_P}|${SHORT_HOST}:${REMOTE_P}|${STATUS}"
        fi
    done)

    # Print header
    printf "${GREEN}%-22s %-30s %-14s %-12s %-10s %-25s %-18s %-18s %s${NC}\n" \
        "INSTANCE ID" "NAME" "TYPE" "STATE" "SSM" "TUNNEL" "PRIVATE IP" "PUBLIC IP" "OPEN PORTS (INBOUND)"
    printf '%.0s-' {1..200}; echo

    # Iterate instances and print rows
    echo "$INSTANCES_JSON" | jq -c '.[]' | while IFS= read -r inst; do
        ID=$(echo "$inst" | jq -r '.ID')
        NAME=$(echo "$inst" | jq -r '.Name // "N/A"')
        TYPE=$(echo "$inst" | jq -r '.Type')
        STATE=$(echo "$inst" | jq -r '.State')
        PRIV_IP=$(echo "$inst" | jq -r '.PrivateIP // "N/A"')
        PUB_IP=$(echo "$inst" | jq -r '.PublicIP // "N/A"')

        # Gather ports from all attached security groups
        SG_IDS=$(echo "$inst" | jq -r '.SGs[]')
        PORTS=""
        for sgid in $SG_IDS; do
            SG_PORTS=$(echo "$SG_PORTS_MAP" | grep "^${sgid}=" | cut -d= -f2-)
            if [ -n "$SG_PORTS" ]; then
                PORTS="${PORTS:+$PORTS,}$SG_PORTS"
            fi
        done
        # Deduplicate and sort ports
        PORTS=$(echo "$PORTS" | tr ',' '\n' | sort -t'-' -k1 -n -u | paste -sd',' -)
        PORTS=${PORTS:-"none"}

        # Lookup SSM status for this instance
        SSM_STATUS=$(echo "$SSM_STATUS_MAP" | grep "^${ID}=" | cut -d= -f2-)
        SSM_STATUS=${SSM_STATUS:-"-"}

        # Lookup tunnel status for this instance
        # Format: local_port|remote_host:port|status
        TUNNEL_INFO=$(echo "$TUNNEL_MAP" | grep "^${ID}=" | cut -d= -f2-)
        if [ -n "$TUNNEL_INFO" ]; then
            T_LOCAL=$(echo "$TUNNEL_INFO" | cut -d'|' -f1)
            T_REMOTE=$(echo "$TUNNEL_INFO" | cut -d'|' -f2)
            T_STATUS=$(echo "$TUNNEL_INFO" | cut -d'|' -f3)
            if [[ "$T_STATUS" == ok* ]]; then
                # Extract socat port if present (ok:8080)
                SOCAT_P=$(echo "$T_STATUS" | cut -d':' -f2)
                if [ -n "$SOCAT_P" ] && [ "$SOCAT_P" != "ok" ]; then
                    TUNNEL_STATUS="${T_REMOTE}â†’:${SOCAT_P}"
                    TUNNEL_OK=1
                else
                    TUNNEL_STATUS="${T_REMOTE}â†’:${T_LOCAL}"
                    TUNNEL_OK=1
                fi
            else
                TUNNEL_STATUS="${T_REMOTE}[DOWN]"
                TUNNEL_OK=0
            fi
        else
            TUNNEL_STATUS="-"
            TUNNEL_OK=-1
        fi

        # Pad text first, then wrap with color (ANSI codes break printf width)
        STATE_PADDED=$(printf "%-12s" "$STATE")
        SSM_PADDED=$(printf "%-10s" "$SSM_STATUS")
        TUNNEL_PADDED=$(printf "%-25s" "$TUNNEL_STATUS")

        # Color the state
        case "$STATE" in
            running) STATE_COL="${GREEN}${STATE_PADDED}${NC}" ;;
            stopped) STATE_COL="${RED}${STATE_PADDED}${NC}" ;;
            *)       STATE_COL="${YELLOW}${STATE_PADDED}${NC}" ;;
        esac

        # Color the SSM status
        case "$SSM_STATUS" in
            Online)         SSM_COL="${GREEN}${SSM_PADDED}${NC}" ;;
            Offline)        SSM_COL="${RED}${SSM_PADDED}${NC}" ;;
            ConnectionLost) SSM_COL="${RED}${SSM_PADDED}${NC}" ;;
            *)              SSM_COL="${YELLOW}${SSM_PADDED}${NC}" ;;
        esac

        # Color the tunnel status
        if [ "$TUNNEL_OK" = "1" ]; then
            TUNNEL_COL="${GREEN}${TUNNEL_PADDED}${NC}"
        elif [ "$TUNNEL_OK" = "0" ]; then
            TUNNEL_COL="${RED}${TUNNEL_PADDED}${NC}"
        else
            TUNNEL_COL="${YELLOW}${TUNNEL_PADDED}${NC}"
        fi

        printf "%-22s %-30s %-14s %b %b %b %-18s %-18s %s\n" \
            "$ID" "$NAME" "$TYPE" "$STATE_COL" "$SSM_COL" "$TUNNEL_COL" "$PRIV_IP" "$PUB_IP" "$PORTS"
    done
}

# --- Function to update the ~/.ssh/config file ---
update_ssh_config() {
    local instance_id=$1
    echo -e "${YELLOW}Updating SSH config file: ${SSH_CONFIG_FILE}...${NC}"
    NEW_HOSTNAME=$(aws ec2 describe-instances --instance-ids "${instance_id}" --query "Reservations[0].Instances[0].PublicDnsName" --output text)
    if [ -z "$NEW_HOSTNAME" ] || [ "$NEW_HOSTNAME" == "None" ]; then
        echo -e "${RED}Error: Could not retrieve a public DNS name for the instance.${NC}"; exit 1; fi
    echo "New public DNS: ${NEW_HOSTNAME}"
    if ! grep -q -E "^\s*Host\s+${INSTANCE_NAME}\s*$" "$SSH_CONFIG_FILE"; then
        echo -e "${RED}Error: Host entry for '${INSTANCE_NAME}' not found in ${SSH_CONFIG_FILE}.${NC}"; exit 1; fi
    awk -v name="${INSTANCE_NAME}" -v host="${NEW_HOSTNAME}" '
        $1 == "Host" && $2 == name { in_block=1 }
        $1 == "Host" && $2 != name { in_block=0 }
        (in_block && tolower($1) == "hostname") {
            print "  HostName " host
        }
        !(in_block && tolower($1) == "hostname") {
            print
        }
    ' "$SSH_CONFIG_FILE" > "${SSH_CONFIG_FILE}.tmp"
    mv "${SSH_CONFIG_FILE}.tmp" "$SSH_CONFIG_FILE"; chmod 600 "$SSH_CONFIG_FILE"
    echo -e "${GREEN}SSH config updated successfully for Host '${INSTANCE_NAME}'.${NC}"
    echo -e "You can now connect using: ${YELLOW}ssh ${INSTANCE_NAME}${NC}"
}

# --- Entrypoint function to run the SSH update independently ---
run_ssh_update() {
    echo -e "${YELLOW}Updating SSH config for running instance: ${INSTANCE_NAME}...${NC}"
    INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].InstanceId" --output text)
    if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
        echo -e "${RED}Error: Instance '${INSTANCE_NAME}' is not running.${NC}\nThe instance must be running to update its hostname."; exit 1; fi
    update_ssh_config "${INSTANCE_ID}"
}

# --- Function to start the instance ---
start_instance() {
    echo -e "${YELLOW}Attempting to start instance: ${INSTANCE_NAME}...${NC}"
    INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=stopped" --query "Reservations[0].Instances[0].InstanceId" --output text)
    if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
        echo -e "${RED}Error: Instance '${INSTANCE_NAME}' not found or is not currently stopped.${NC}"; exit 1; fi
    echo "Found instance ID: ${INSTANCE_ID}"; aws ec2 start-instances --instance-ids "${INSTANCE_ID}" > /dev/null
    echo -e "${GREEN}Start command sent. Waiting for instance to be in 'running' state...${NC}"
    aws ec2 wait instance-running --instance-ids "${INSTANCE_ID}"; echo -e "${GREEN}Instance is now running.${NC}"
    update_ssh_config "${INSTANCE_ID}"
}

# --- Function to stop the instance ---
stop_instance() {
    echo -e "${YELLOW}Attempting to stop instance: ${INSTANCE_NAME}...${NC}"
    INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].InstanceId" --output text)
    if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
        echo -e "${GREEN}Instance '${INSTANCE_NAME}' is already stopped.${NC}"; return 0; fi
    echo "Found running instance ID: ${INSTANCE_ID}"; aws ec2 stop-instances --instance-ids "${INSTANCE_ID}" > /dev/null
    echo -e "${GREEN}Stop command sent. Waiting for instance to be in 'stopped' state...${NC}"
    aws ec2 wait instance-stopped --instance-ids "${INSTANCE_ID}"; echo -e "${GREEN}Instance is now stopped.${NC}"
}

# --- NEW: Function to force stop the instance ---
force_stop_instance() {
    echo -e "${RED}ðŸ›‘ WARNING: Force stopping an instance can lead to data corruption.${NC}"
    echo -e "${YELLOW}The instance will not shut down gracefully. This is like pulling the power cord.${NC}"
    read -p "Are you sure you want to proceed? (y/n) " -n 1 -r
    echo # move to a new line
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 1
    fi

    echo -e "${YELLOW}Attempting to force stop instance: ${INSTANCE_NAME}...${NC}"
    INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].InstanceId" --output text)
    if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
        echo -e "${GREEN}Instance '${INSTANCE_NAME}' is not running.${NC}"; return 0; fi
    echo "Found running instance ID: ${INSTANCE_ID}"
    aws ec2 stop-instances --instance-ids "${INSTANCE_ID}" --force > /dev/null
    echo -e "${GREEN}Force stop command sent. Waiting for instance to be in 'stopped' state...${NC}"
    aws ec2 wait instance-stopped --instance-ids "${INSTANCE_ID}"
    echo -e "${GREEN}Instance is now stopped.${NC}"
}

# --- Function to switch the instance type ---
switch_type() {
    local target_type_arg=$1
    if [[ "$target_type_arg" == "gpu" ]]; then NEW_TYPE=$GPU_INSTANCE_TYPE; elif [[ "$target_type_arg" == "cpu" ]]; then NEW_TYPE=$CPU_INSTANCE_TYPE; else
        echo -e "${RED}Error: Invalid type '${target_type_arg}'. Use 'gpu' or 'cpu'.${NC}"; usage; fi
    echo -e "${YELLOW}Fetching current status for instance '${INSTANCE_NAME}'...${NC}"
    INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${INSTANCE_NAME}" --query "Reservations[0].Instances[0].InstanceId" --output text)
    if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
        echo -e "${RED}Error: Instance '${INSTANCE_NAME}' not found.${NC}"; exit 1; fi
    INSTANCE_INFO=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[0].Instances[0].{Type:InstanceType, State:State.Name}" --output json)
    CURRENT_TYPE=$(echo "$INSTANCE_INFO" | jq -r .Type); INSTANCE_STATE=$(echo "$INSTANCE_INFO" | jq -r .State)
    echo -e "Current instance type is: ${GREEN}${CURRENT_TYPE}${NC}"
    echo -e "Attempting to switch to type: ${YELLOW}${NEW_TYPE}${NC}"
    if [ "$CURRENT_TYPE" == "$NEW_TYPE" ]; then echo -e "${GREEN}Instance is already the target type. No action needed.${NC}"; exit 0; fi
    if [ "$INSTANCE_STATE" == "running" ]; then echo "Instance is running. It will be stopped automatically before changing type."; stop_instance
    elif [ "$INSTANCE_STATE" != "stopped" ]; then echo -e "${RED}Error: Instance is in state '${INSTANCE_STATE}'. Please wait for it to be stopped or running.${NC}"; exit 1; fi
    echo "Instance is stopped. Modifying type to ${NEW_TYPE}..."; aws ec2 modify-instance-attribute --instance-id "${INSTANCE_ID}" --instance-type "{\"Value\": \"${NEW_TYPE}\"}"
    echo -e "${GREEN}Success! Instance type for '${INSTANCE_NAME}' is now '${NEW_TYPE}'.${NC}"; echo "You can start it with './manage-ec2.sh start'."
}

# --- Function to start SSM tunnel with socat relay ---
tunnel_start() {
    # Check required variables for tunnel
    if [ -z "$BASTION_INSTANCE_ID" ]; then
        echo -e "${RED}âŒ Error: BASTION_INSTANCE_ID environment variable is not set${NC}"
        echo "   Please set BASTION_INSTANCE_ID to the bastion EC2 instance ID"
        echo "   Example: export BASTION_INSTANCE_ID=i-0123456789abcdef0"
        exit 1
    fi
    if [ -z "$REMOTE_HOST" ]; then
        echo -e "${RED}âŒ Error: REMOTE_HOST environment variable is not set${NC}"
        echo "   Please set REMOTE_HOST to the target host accessible from the bastion"
        echo "   Example: export REMOTE_HOST=myservice.internal.example.com"
        exit 1
    fi

    # Check if tunnel is already up
    if nc -z localhost "${LOCAL_PORT}" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Tunnel already active at localhost:${LOCAL_PORT}${NC}"
        exit 0
    fi

    echo -e "${YELLOW}Tunnel not found. Establishing connection...${NC}"

    # Check AWS auth
    if ! aws sts get-caller-identity >/dev/null 2>&1; then
        echo -e "${RED}AWS session expired or missing. Please login first.${NC}"
        exit 1
    fi

    # Start SSM session on internal port (binds to localhost only)
    echo "Starting SSM tunnel to ${REMOTE_HOST}:${REMOTE_PORT} via ${BASTION_INSTANCE_ID}..."
    nohup aws ssm start-session \
        --target "${BASTION_INSTANCE_ID}" \
        --document-name AWS-StartPortForwardingSessionToRemoteHost \
        --parameters "{\"host\":[\"${REMOTE_HOST}\"],\"portNumber\":[\"${REMOTE_PORT}\"],\"localPortNumber\":[\"${INTERNAL_PORT}\"]}" \
        > /tmp/ssm-session.log 2>&1 < /dev/null &

    # Wait for SSM tunnel
    echo -e "${YELLOW}Waiting for SSM tunnel on localhost:${INTERNAL_PORT}...${NC}"
    for i in $(seq 1 10); do
        if nc -z localhost "${INTERNAL_PORT}" 2>/dev/null; then
            echo -e "${GREEN}âœ“ SSM tunnel established on localhost:${INTERNAL_PORT}${NC}"
            break
        fi
        sleep 1
    done

    if ! nc -z localhost "${INTERNAL_PORT}" 2>/dev/null; then
        echo -e "${RED}âœ— Failed to establish SSM tunnel. Check /tmp/ssm-session.log${NC}"
        cat /tmp/ssm-session.log
        exit 1
    fi

    # Start socat relay to expose on all interfaces
    echo -e "${YELLOW}Starting socat relay on 0.0.0.0:${LOCAL_PORT} -> localhost:${INTERNAL_PORT}...${NC}"
    nohup socat TCP-LISTEN:${LOCAL_PORT},fork,reuseaddr,bind=0.0.0.0 TCP:127.0.0.1:${INTERNAL_PORT} \
        > /tmp/socat-relay.log 2>&1 < /dev/null &

    # Wait for socat
    sleep 1
    if nc -z localhost "${LOCAL_PORT}" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Tunnel accessible at 0.0.0.0:${LOCAL_PORT}${NC}"
    else
        echo -e "${RED}âœ— Failed to start socat relay. Check /tmp/socat-relay.log${NC}"
        cat /tmp/socat-relay.log
        exit 1
    fi
}

# --- Function to stop SSM tunnel and socat relay ---
tunnel_stop() {
    echo -e "${YELLOW}Stopping SSM tunnel...${NC}"

    # Kill socat relay
    if pkill -f "socat.*TCP-LISTEN:${LOCAL_PORT}" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Stopped socat relay${NC}"
    else
        echo "  No socat relay found"
    fi

    # Kill SSM session
    if pkill -f "session-manager-plugin" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Stopped SSM session${NC}"
    else
        echo "  No SSM session found"
    fi

    echo "Done."
}

# --- Function to test tunnel connection ---
tunnel_test() {
    if [ -z "$HEALTH_URL" ]; then
        # Default to checking if port is open
        if nc -z localhost "${LOCAL_PORT}" 2>/dev/null; then
            echo -e "${GREEN}âœ“ Tunnel port ${LOCAL_PORT} is open${NC}"
        else
            echo -e "${RED}âœ— Tunnel port ${LOCAL_PORT} is not accessible${NC}"
            echo "  Make sure the tunnel is running: $0 tunnel"
            exit 1
        fi
    else
        # Test health endpoint
        if curl -f -s --max-time 2 "$HEALTH_URL" | grep -qi "ok\|healthy\|success"; then
            echo -e "${GREEN}âœ“ Health check passed at ${HEALTH_URL}${NC}"
        else
            echo -e "${RED}âœ— Failed to connect to ${HEALTH_URL}${NC}"
            echo "  Make sure the tunnel is running: $0 tunnel"
            exit 1
        fi
    fi
}

# --- Main script logic: Parse command-line arguments ---
usage() {
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "EC2 Instance Commands:"
    echo "  list          - Lists all EC2 instances with status and open ports"
    echo "  start         - Starts the instance (requires INSTANCE_NAME)"
    echo "  stop          - Stops the instance gracefully (requires INSTANCE_NAME)"
    echo "  force-stop    - Force stops the instance (requires INSTANCE_NAME)"
    echo "  switch <type> - Changes instance type to 'gpu' or 'cpu' (requires INSTANCE_NAME)"
    echo "  update-ssh    - Updates ~/.ssh/config for the running instance (requires INSTANCE_NAME)"
    echo "  status        - Displays deployment information (requires INSTANCE_NAME)"
    echo ""
    echo "SSM Tunnel Commands:"
    echo "  tunnel        - Start SSM port forwarding tunnel with socat relay"
    echo "  tunnel-stop   - Stop the SSM tunnel and socat relay"
    echo "  tunnel-test   - Test if the tunnel is working"
    echo ""
    echo "Required Environment Variables:"
    echo "  AWS_DEFAULT_REGION or AWS_REGION  - AWS region"
    echo "  AWS_PROFILE or AWS_ACCESS_KEY_ID  - AWS credentials"
    echo ""
    echo "Tunnel Environment Variables:"
    echo "  BASTION_INSTANCE_ID  - EC2 instance ID of the bastion host"
    echo "  REMOTE_HOST          - Target host accessible from bastion"
    echo "  REMOTE_PORT          - Target port (default: 80)"
    echo "  LOCAL_PORT           - Local port to expose (default: 8080)"
    echo "  HEALTH_URL           - Optional URL for tunnel-test health check"
    exit 1
}

if ! command -v jq &> /dev/null; then
    echo -e "${RED}'jq' is not installed. This script requires jq to reliably parse instance data.${NC}"
    echo "Please install it (e.g., 'sudo apt-get install jq' or 'brew install jq') and try again."; exit 1; fi
if [ -z "$1" ]; then usage; fi

case "$1" in
    list) list_instances ;;
    start) start_instance ;;
    stop) stop_instance ;;
    force-stop) force_stop_instance ;;
    switch) if [ -z "$2" ]; then echo -e "${RED}Error: The 'switch' command requires a second argument: 'gpu' or 'cpu'.${NC}"; usage; fi; switch_type "$2" ;;
    update-ssh) run_ssh_update ;;
    status) show_status ;;
    tunnel) tunnel_start ;;
    tunnel-stop) tunnel_stop ;;
    tunnel-test) tunnel_test ;;
    *) usage ;;
esac
