//! Reverse proxy management: nginx config + /etc/hosts for seamless local access.
//! Works on both macOS (Homebrew nginx) and Linux (apt/yum nginx + systemd).

use std::path::PathBuf;
use std::process::{Command, Stdio};

use crate::error::{AppError, Result};

const HOSTS_TAG: &str = "# awsx2-proxy";

fn is_macos() -> bool {
    cfg!(target_os = "macos")
}

// ── Nginx config directory detection ─────────────────────────────────────────

/// Returns the directory where per-site nginx configs should be written.
/// On Debian/Ubuntu with sites-available/sites-enabled, writes to sites-available
/// and symlinks into sites-enabled.
fn nginx_servers_dir() -> Option<NginxDir> {
    // macOS Homebrew paths
    for dir in &[
        "/opt/homebrew/etc/nginx/servers",
        "/usr/local/etc/nginx/servers",
    ] {
        let path = PathBuf::from(dir);
        if path.is_dir() {
            return Some(NginxDir::Direct(path));
        }
    }

    // Linux: prefer sites-available + sites-enabled (Debian/Ubuntu convention)
    let available = PathBuf::from("/etc/nginx/sites-available");
    let enabled = PathBuf::from("/etc/nginx/sites-enabled");
    if available.is_dir() && enabled.is_dir() {
        return Some(NginxDir::SitesAvailable {
            available,
            enabled,
        });
    }

    // Linux fallback: conf.d (RHEL/CentOS/Amazon Linux)
    let confd = PathBuf::from("/etc/nginx/conf.d");
    if confd.is_dir() {
        return Some(NginxDir::Direct(confd));
    }

    None
}

enum NginxDir {
    /// Write config directly into this directory.
    Direct(PathBuf),
    /// Write to sites-available, symlink into sites-enabled.
    SitesAvailable {
        available: PathBuf,
        enabled: PathBuf,
    },
}

impl NginxDir {
    /// Write a config file and ensure it's active. Returns the path written.
    fn write_config(&self, filename: &str, content: &str) -> std::io::Result<PathBuf> {
        match self {
            NginxDir::Direct(dir) => {
                let path = dir.join(filename);
                std::fs::write(&path, content)?;
                Ok(path)
            }
            NginxDir::SitesAvailable { available, enabled } => {
                let avail_path = available.join(filename);
                std::fs::write(&avail_path, content)?;
                let link_path = enabled.join(filename);
                // Remove stale symlink if it exists
                let _ = std::fs::remove_file(&link_path);
                std::os::unix::fs::symlink(&avail_path, &link_path)?;
                Ok(avail_path)
            }
        }
    }

    /// Remove a config file (and its symlink if applicable).
    fn remove_config(&self, filename: &str) {
        match self {
            NginxDir::Direct(dir) => {
                let _ = std::fs::remove_file(dir.join(filename));
            }
            NginxDir::SitesAvailable { available, enabled } => {
                let _ = std::fs::remove_file(enabled.join(filename));
                let _ = std::fs::remove_file(available.join(filename));
            }
        }
    }

    /// Iterate over active config filenames matching a predicate.
    fn active_configs(&self) -> Vec<String> {
        let dir = match self {
            NginxDir::Direct(d) => d,
            NginxDir::SitesAvailable { enabled, .. } => enabled,
        };
        let mut names = vec![];
        if let Ok(entries) = std::fs::read_dir(dir) {
            for entry in entries.flatten() {
                if let Some(name) = entry.file_name().to_str() {
                    names.push(name.to_string());
                }
            }
        }
        names
    }
}

fn config_filename(hostname: &str) -> String {
    format!("awsx2-{}.conf", hostname)
}

// ── Public API ───────────────────────────────────────────────────────────────

/// Set up a local nginx reverse proxy so the hostname resolves to localhost and
/// nginx forwards traffic to the tunnel's local port.
pub fn setup_proxy(hostname: &str, local_port: u16) -> Result<()> {
    let dir = nginx_servers_dir().ok_or_else(|| {
        let hint = if is_macos() {
            "Install nginx: brew install nginx"
        } else {
            "Install nginx: sudo apt install nginx  (or yum install nginx)"
        };
        AppError::Tunnel(format!("No nginx servers directory found. {}", hint))
    })?;

    // 1. Write nginx config
    let config = format!(
        r#"# Auto-generated by awsx2 — do not edit
server {{
    listen 80;
    server_name {hostname};

    location / {{
        proxy_pass http://127.0.0.1:{local_port};
        proxy_set_header Host {hostname};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }}
}}
"#
    );
    let config_path = dir.write_config(&config_filename(hostname), &config)?;
    println!("  nginx config: {}", config_path.display());

    // 2. Add /etc/hosts entry (requires sudo)
    add_hosts_entry(hostname)?;

    // 3. Reload nginx
    reload_nginx()?;

    // 4. Flush DNS cache
    flush_dns_cache();

    Ok(())
}

/// Remove all awsx2-generated proxy configs + /etc/hosts entries.
pub fn teardown_all_proxies() {
    if let Some(dir) = nginx_servers_dir() {
        let awsx2_configs: Vec<String> = dir
            .active_configs()
            .into_iter()
            .filter(|n| n.starts_with("awsx2-") && n.ends_with(".conf"))
            .collect();
        for name in awsx2_configs {
            dir.remove_config(&name);
        }
    }

    // Remove all awsx2-proxy tagged lines from /etc/hosts.
    // Read, filter, write back — portable across macOS and Linux.
    remove_hosts_entries();

    let _ = reload_nginx();
    flush_dns_cache();
}

/// Check if any awsx2 proxy configs exist.
pub fn has_active_proxies() -> bool {
    if let Some(dir) = nginx_servers_dir() {
        return dir
            .active_configs()
            .iter()
            .any(|n| n.starts_with("awsx2-") && n.ends_with(".conf"));
    }
    false
}

// ── /etc/hosts management ────────────────────────────────────────────────────

fn add_hosts_entry(hostname: &str) -> Result<()> {
    // Check if already present
    if let Ok(hosts) = std::fs::read_to_string("/etc/hosts") {
        for line in hosts.lines() {
            if line.contains(hostname) && line.contains(HOSTS_TAG) {
                println!("  /etc/hosts: already has {}", hostname);
                return Ok(());
            }
        }
    }

    let entry = format!("127.0.0.1 {} {}\n", hostname, HOSTS_TAG);
    let mut child = Command::new("sudo")
        .args(["tee", "-a", "/etc/hosts"])
        .stdin(Stdio::piped())
        .stdout(Stdio::null())
        .spawn()?;
    if let Some(mut stdin) = child.stdin.take() {
        use std::io::Write;
        stdin.write_all(entry.as_bytes())?;
    }
    let status = child.wait()?;
    if !status.success() {
        return Err(AppError::Tunnel(
            "Failed to add /etc/hosts entry (sudo required)".into(),
        ));
    }
    println!("  /etc/hosts: added 127.0.0.1 {}", hostname);
    Ok(())
}

/// Remove all awsx2-proxy tagged lines from /etc/hosts.
/// Reads the file, filters out tagged lines, writes back via sudo tee.
fn remove_hosts_entries() {
    let hosts = match std::fs::read_to_string("/etc/hosts") {
        Ok(h) => h,
        Err(_) => return,
    };
    let filtered: String = hosts
        .lines()
        .filter(|line| !line.contains(HOSTS_TAG))
        .map(|line| format!("{}\n", line))
        .collect();
    if filtered.len() == hosts.len() {
        return; // nothing to remove
    }
    let mut child = match Command::new("sudo")
        .args(["tee", "/etc/hosts"])
        .stdin(Stdio::piped())
        .stdout(Stdio::null())
        .spawn()
    {
        Ok(c) => c,
        Err(_) => return,
    };
    if let Some(mut stdin) = child.stdin.take() {
        use std::io::Write;
        let _ = stdin.write_all(filtered.as_bytes());
    }
    let _ = child.wait();
}

// ── Nginx management ─────────────────────────────────────────────────────────

/// Find the absolute path to the nginx binary.
fn nginx_bin() -> String {
    for path in &[
        "/opt/homebrew/bin/nginx",
        "/usr/local/bin/nginx",
        "/usr/bin/nginx",
        "/usr/sbin/nginx",
    ] {
        if std::path::Path::new(path).exists() {
            return path.to_string();
        }
    }
    "nginx".to_string()
}

/// Check if nginx is managed by systemd (Linux).
fn has_systemctl_nginx() -> bool {
    if is_macos() {
        return false;
    }
    Command::new("systemctl")
        .args(["cat", "nginx.service"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_or(false, |s| s.success())
}

fn reload_nginx() -> Result<()> {
    let bin = nginx_bin();

    // Test config syntax (best-effort). Try without sudo first; if it fails
    // due to permissions (e.g. log files owned by root) we skip the test and
    // let the actual start/reload with sudo surface real errors.
    if let Ok(o) = Command::new(&bin).args(["-t"]).output() {
        if !o.status.success() {
            let err = String::from_utf8_lossy(&o.stderr);
            let is_perm = err.contains("Permission denied") || err.contains("permission denied");
            if !is_perm {
                return Err(AppError::Tunnel(format!("nginx config error:\n{}", err.trim())));
            }
            // Permission error — proceed anyway; sudo start/reload will work.
        }
    }

    // On Linux with systemd, prefer systemctl for start/reload.
    if has_systemctl_nginx() {
        return reload_nginx_systemd();
    }

    // macOS / non-systemd path: use nginx binary directly.
    reload_nginx_direct(&bin)
}

/// Reload/start nginx via systemctl (Linux).
fn reload_nginx_systemd() -> Result<()> {
    // Check if active
    let is_active = Command::new("systemctl")
        .args(["is-active", "--quiet", "nginx"])
        .status()
        .map_or(false, |s| s.success());

    let action = if is_active { "reload" } else { "start" };

    // Try without sudo (works if user has passwordless systemctl rights)
    let ok = Command::new("systemctl")
        .args([action, "nginx"])
        .status()
        .map_or(false, |s| s.success());
    if ok {
        println!("  nginx: {} (systemctl)", action);
        return Ok(());
    }

    // Fall back to sudo
    let ok = Command::new("sudo")
        .args(["systemctl", action, "nginx"])
        .status()
        .map_or(false, |s| s.success());
    if ok {
        println!("  nginx: {} (sudo systemctl)", action);
        return Ok(());
    }

    Err(AppError::Tunnel(format!(
        "Failed to {} nginx — run `sudo systemctl {} nginx` manually",
        action, action
    )))
}

/// Reload/start nginx via the binary directly (macOS / non-systemd).
fn reload_nginx_direct(bin: &str) -> Result<()> {
    // Check if nginx is already running
    let is_running = Command::new("pgrep")
        .args(["-x", "nginx"])
        .stdout(Stdio::null())
        .status()
        .map_or(false, |s| s.success());

    if is_running {
        // Reload — try without sudo, then with sudo.
        // Use .status() so sudo can prompt for a password via the terminal.
        let ok = Command::new(bin)
            .args(["-s", "reload"])
            .status()
            .map_or(false, |s| s.success());
        if ok {
            println!("  nginx: reloaded");
            return Ok(());
        }
        let ok = Command::new("sudo")
            .args([bin, "-s", "reload"])
            .status()
            .map_or(false, |s| s.success());
        if ok {
            println!("  nginx: reloaded");
            return Ok(());
        }
    }

    // Not running — start it (port 80 requires sudo).
    // Use .status() so sudo can prompt for a password via the terminal.
    let ok = Command::new("sudo")
        .args([bin])
        .status()
        .map_or(false, |s| s.success());
    if ok {
        println!("  nginx: started");
        return Ok(());
    }

    Err(AppError::Tunnel("Failed to start nginx (sudo required — run `sudo nginx` first)".into()))
}

fn flush_dns_cache() {
    if is_macos() {
        // macOS: flush via dscacheutil + mDNSResponder
        let _ = Command::new("sudo")
            .args(["dscacheutil", "-flushcache"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status();
        let _ = Command::new("sudo")
            .args(["killall", "-HUP", "mDNSResponder"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status();
    } else {
        // Linux: try systemd-resolved, then nscd
        let _ = Command::new("sudo")
            .args(["systemd-resolve", "--flush-caches"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status();
        let _ = Command::new("sudo")
            .args(["resolvectl", "flush-caches"])
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status();
        // nscd (older distros / Amazon Linux)
        if std::path::Path::new("/usr/sbin/nscd").exists() {
            let _ = Command::new("sudo")
                .args(["nscd", "-i", "hosts"])
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .status();
        }
    }
}
