#!/bin/bash

# Port Scanner Script
# Scans for open ports on specified hosts using netcat or other tools

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Default configuration
TARGET_HOST=""
PORT_RANGE=""
TIMEOUT=2
SCAN_TYPE="tcp"
VERBOSE=false
OUTPUT_FILE=""
THREADS=10

# Common port lists
COMMON_PORTS="22,23,25,53,80,110,143,443,993,995,1433,3306,3389,5432,5900,8080"
WEB_PORTS="80,443,8000,8080,8443,8888,9000"
DB_PORTS="1433,3306,5432,1521,27017"

# Function to display usage
usage() {
    echo "Port Scanner Tool"
    echo
    echo "Usage: $0 -h <host> [OPTIONS]"
    echo
    echo "Required:"
    echo "  -h, --host HOST         Target host to scan"
    echo
    echo "Options:"
    echo "  -p, --ports RANGE       Port range (e.g., 1-1000, 80,443, common, web, db)"
    echo "  -t, --timeout SECONDS   Connection timeout (default: 2)"
    echo "  -s, --scan-type TYPE    Scan type: tcp, udp (default: tcp)"
    echo "  -v, --verbose           Verbose output"
    echo "  -o, --output FILE       Save results to file"
    echo "  -j, --threads NUMBER    Number of parallel scans (default: 10)"
    echo "  --help                  Show this help message"
    echo
    echo "Port Range Examples:"
    echo "  common                  Scan common ports (22,25,53,80,443,etc.)"
    echo "  web                     Scan web ports (80,443,8080,etc.)"
    echo "  db                      Scan database ports (3306,5432,etc.)"
    echo "  1-1000                  Scan ports 1 to 1000"
    echo "  80,443,8080             Scan specific ports"
    echo
    echo "Examples:"
    echo "  $0 -h google.com -p common"
    echo "  $0 -h 192.168.1.1 -p 1-1000 -t 1"
    echo "  $0 -h example.com -p web -v -o scan_results.txt"
    exit 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--host)
            TARGET_HOST="$2"
            shift 2
            ;;
        -p|--ports)
            PORT_RANGE="$2"
            shift 2
            ;;
        -t|--timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        -s|--scan-type)
            SCAN_TYPE="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -j|--threads)
            THREADS="$2"
            shift 2
            ;;
        --help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Validate required arguments
if [ -z "$TARGET_HOST" ]; then
    echo -e "${RED}‚ùå Error: Target host is required${NC}"
    usage
fi

if [ -z "$PORT_RANGE" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  No port range specified, using common ports${NC}"
    PORT_RANGE="common"
fi

# Function to resolve hostname to IP
resolve_host() {
    local host="$1"
    if command -v nslookup >/dev/null 2>&1; then
        nslookup "$host" 2>/dev/null | grep -A1 "Name:" | tail -1 | awk '{print $2}' | head -1
    elif command -v dig >/dev/null 2>&1; then
        dig +short "$host" | head -1
    else
        echo "$host"
    fi
}

# Function to check if port is open using netcat
check_port_nc() {
    local host="$1"
    local port="$2"
    local timeout="$3"
    
    if [ "$SCAN_TYPE" = "udp" ]; then
        timeout "$timeout" nc -u -z "$host" "$port" 2>/dev/null
    else
        timeout "$timeout" nc -z "$host" "$port" 2>/dev/null
    fi
}

# Function to check if port is open using bash (fallback)
check_port_bash() {
    local host="$1"
    local port="$2"
    local timeout="$3"
    
    timeout "$timeout" bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null
}

# Function to get service name for port
get_service_name() {
    local port="$1"
    case "$port" in
        21) echo "FTP" ;;
        22) echo "SSH" ;;
        23) echo "Telnet" ;;
        25) echo "SMTP" ;;
        53) echo "DNS" ;;
        80) echo "HTTP" ;;
        110) echo "POP3" ;;
        143) echo "IMAP" ;;
        443) echo "HTTPS" ;;
        993) echo "IMAPS" ;;
        995) echo "POP3S" ;;
        1433) echo "MSSQL" ;;
        3306) echo "MySQL" ;;
        3389) echo "RDP" ;;
        5432) echo "PostgreSQL" ;;
        5900) echo "VNC" ;;
        8080) echo "HTTP-Alt" ;;
        *) echo "Unknown" ;;
    esac
}

# Function to expand port range
expand_ports() {
    local range="$1"
    local ports=""
    
    case "$range" in
        "common")
            ports="$COMMON_PORTS"
            ;;
        "web")
            ports="$WEB_PORTS"
            ;;
        "db")
            ports="$DB_PORTS"
            ;;
        *-*)
            # Range format (e.g., 1-1000)
            local start=$(echo "$range" | cut -d'-' -f1)
            local end=$(echo "$range" | cut -d'-' -f2)
            ports=$(seq -s, "$start" "$end")
            ;;
        *)
            # Assume comma-separated list
            ports="$range"
            ;;
    esac
    
    echo "$ports"
}

# Function to scan a single port
scan_port() {
    local host="$1"
    local port="$2"
    local timeout="$3"
    local result="CLOSED"
    
    # Try netcat first, then bash fallback
    if command -v nc >/dev/null 2>&1; then
        if check_port_nc "$host" "$port" "$timeout"; then
            result="OPEN"
        fi
    elif check_port_bash "$host" "$port" "$timeout"; then
        result="OPEN"
    fi
    
    # Output result
    local service=$(get_service_name "$port")
    if [ "$result" = "OPEN" ]; then
        echo -e "${GREEN}$port\t$result\t$service${NC}"
        if [ -n "$OUTPUT_FILE" ]; then
            echo "$port	$result	$service" >> "$OUTPUT_FILE"
        fi
    elif [ "$VERBOSE" = true ]; then
        echo -e "${RED}$port\t$result\t$service${NC}"
        if [ -n "$OUTPUT_FILE" ]; then
            echo "$port	$result	$service" >> "$OUTPUT_FILE"
        fi
    fi
}

# Main scanning function
perform_scan() {
    local host="$1"
    local ports="$2"
    
    echo -e "${BLUE}üîç Scanning $host...${NC}"
    echo -e "${BLUE}Scan type: $SCAN_TYPE${NC}"
    echo -e "${BLUE}Timeout: ${TIMEOUT}s${NC}"
    echo
    
    # Resolve hostname
    local ip=$(resolve_host "$host")
    if [ -n "$ip" ] && [ "$ip" != "$host" ]; then
        echo -e "${CYAN}Resolved $host to $ip${NC}"
        echo
    fi
    
    # Prepare output file
    if [ -n "$OUTPUT_FILE" ]; then
        echo "# Port scan results for $host" > "$OUTPUT_FILE"
        echo "# Date: $(date)" >> "$OUTPUT_FILE"
        echo "# Port	Status	Service" >> "$OUTPUT_FILE"
    fi
    
    echo -e "${CYAN}Port\tStatus\tService${NC}"
    echo -e "${CYAN}----\t------\t-------${NC}"
    
    # Convert comma-separated ports to array
    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    
    # Create a temporary directory for parallel processing
    TEMP_DIR=$(mktemp -d)
    
    # Function to scan ports in parallel
    scan_batch() {
        local batch_ports=("$@")
        for port in "${batch_ports[@]}"; do
            scan_port "$host" "$port" "$TIMEOUT"
        done
    }
    
    # Split ports into batches for parallel processing
    batch_size=$((${#PORT_ARRAY[@]} / THREADS))
    if [ $batch_size -eq 0 ]; then
        batch_size=1
    fi
    
    # Process ports in parallel batches
    for ((i=0; i<${#PORT_ARRAY[@]}; i+=batch_size)); do
        batch=("${PORT_ARRAY[@]:i:batch_size}")
        scan_batch "${batch[@]}" &
        
        # Limit number of background processes
        while [ $(jobs -r | wc -l) -ge $THREADS ]; do
            sleep 0.1
        done
    done
    
    # Wait for all background jobs to complete
    wait
    
    # Clean up
    rm -rf "$TEMP_DIR"
}

# Function to display banner
display_banner() {
    echo -e "${CYAN}========================================${NC}"
    echo -e "${CYAN}         PORT SCANNER TOOL              ${NC}"
    echo -e "${CYAN}========================================${NC}"
    echo -e "${YELLOW}Target:${NC} $TARGET_HOST"
    echo -e "${YELLOW}Ports:${NC} $PORT_RANGE"
    echo -e "${YELLOW}Threads:${NC} $THREADS"
    echo -e "${YELLOW}Started:${NC} $(date)"
    echo -e "${CYAN}========================================${NC}"
    echo
}

# Function to display summary
display_summary() {
    echo
    echo -e "${CYAN}========================================${NC}"
    echo -e "${YELLOW}Scan completed:${NC} $(date)"
    
    if [ -n "$OUTPUT_FILE" ]; then
        local open_count=$(grep -c "OPEN" "$OUTPUT_FILE" 2>/dev/null || echo "0")
        echo -e "${YELLOW}Open ports found:${NC} $open_count"
        echo -e "${YELLOW}Results saved to:${NC} $OUTPUT_FILE"
    fi
    
    echo -e "${CYAN}========================================${NC}"
}

# Check dependencies
if ! command -v nc >/dev/null 2>&1 && ! command -v timeout >/dev/null 2>&1; then
    echo -e "${RED}‚ùå Error: This script requires 'nc' (netcat) or 'timeout' command${NC}"
    echo -e "${YELLOW}Install with: sudo apt-get install netcat-openbsd (Ubuntu/Debian)${NC}"
    echo -e "${YELLOW}              sudo yum install nmap-ncat (RHEL/CentOS)${NC}"
    exit 1
fi

# Main execution
display_banner

# Expand port range
EXPANDED_PORTS=$(expand_ports "$PORT_RANGE")

if [ "$VERBOSE" = true ]; then
    echo -e "${BLUE}Expanded ports: $EXPANDED_PORTS${NC}"
    echo
fi

# Perform the scan
perform_scan "$TARGET_HOST" "$EXPANDED_PORTS"

# Display summary
display_summary

echo -e "${GREEN}üéâ Port scan completed!${NC}"
