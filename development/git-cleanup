#!/bin/bash

# Git Repository Cleanup Script
# Cleans up merged branches, optimizes repository, and provides maintenance utilities

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Function to check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Error: Not in a git repository${NC}"
        exit 1
    fi
}

# Function to display usage
usage() {
    echo "Git Repository Cleanup Tool"
    echo
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Options:"
    echo "  -a, --all           Run all cleanup operations"
    echo "  -b, --branches      Clean merged branches"
    echo "  -t, --tags          Clean old tags (interactive)"
    echo "  -s, --stash         Clean old stash entries"
    echo "  -o, --optimize      Optimize repository (gc, prune)"
    echo "  -r, --remotes       Clean remote tracking branches"
    echo "  -i, --interactive   Interactive mode for branch selection"
    echo "  -n, --dry-run       Show what would be done without executing"
    echo "  -h, --help          Show this help message"
    echo
    echo "Examples:"
    echo "  $0 -a                # Run all cleanup operations"
    echo "  $0 -b -o             # Clean branches and optimize"
    echo "  $0 -n -b             # Dry run for branch cleanup"
    exit 0
}

# Parse command line arguments
ALL_CLEANUP=false
CLEAN_BRANCHES=false
CLEAN_TAGS=false
CLEAN_STASH=false
OPTIMIZE_REPO=false
CLEAN_REMOTES=false
INTERACTIVE=false
DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--all)
            ALL_CLEANUP=true
            shift
            ;;
        -b|--branches)
            CLEAN_BRANCHES=true
            shift
            ;;
        -t|--tags)
            CLEAN_TAGS=true
            shift
            ;;
        -s|--stash)
            CLEAN_STASH=true
            shift
            ;;
        -o|--optimize)
            OPTIMIZE_REPO=true
            shift
            ;;
        -r|--remotes)
            CLEAN_REMOTES=true
            shift
            ;;
        -i|--interactive)
            INTERACTIVE=true
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# If --all is specified, enable all operations
if [ "$ALL_CLEANUP" = true ]; then
    CLEAN_BRANCHES=true
    CLEAN_TAGS=true
    CLEAN_STASH=true
    OPTIMIZE_REPO=true
    CLEAN_REMOTES=true
fi

# If no options specified, show usage
if [ "$CLEAN_BRANCHES" = false ] && [ "$CLEAN_TAGS" = false ] && [ "$CLEAN_STASH" = false ] && [ "$OPTIMIZE_REPO" = false ] && [ "$CLEAN_REMOTES" = false ]; then
    usage
fi

# Check if we're in a git repository
check_git_repo

# Get current branch and repository info
CURRENT_BRANCH=$(git branch --show-current)
REPO_NAME=$(basename `git rev-parse --show-toplevel`)

echo -e "${BLUE}üßπ Git Cleanup Tool${NC}"
echo -e "${BLUE}===================${NC}"
echo -e "${GREEN}Repository:${NC} $REPO_NAME"
echo -e "${GREEN}Current branch:${NC} $CURRENT_BRANCH"
if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}üîç DRY RUN MODE - No changes will be made${NC}"
fi
echo

# Function to execute or show command
execute_cmd() {
    local cmd="$1"
    local description="$2"
    
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}[DRY RUN] $description:${NC} $cmd"
    else
        echo -e "${YELLOW}$description...${NC}"
        eval "$cmd"
        echo -e "${GREEN}‚úì Done${NC}"
    fi
}

# Clean merged branches
if [ "$CLEAN_BRANCHES" = true ]; then
    echo -e "${BLUE}üåø Cleaning merged branches...${NC}"
    
    # Get merged branches (excluding current and main/master)
    MERGED_BRANCHES=$(git branch --merged | grep -v "^\*" | grep -v "main" | grep -v "master" | grep -v "develop" | xargs echo)
    
    if [ -n "$MERGED_BRANCHES" ]; then
        echo -e "${YELLOW}Found merged branches:${NC}"
        for branch in $MERGED_BRANCHES; do
            echo -e "  - $branch"
        done
        
        if [ "$INTERACTIVE" = true ] && [ "$DRY_RUN" = false ]; then
            read -p "Delete these branches? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                execute_cmd "git branch -d $MERGED_BRANCHES" "Deleting merged branches"
            else
                echo -e "${YELLOW}Skipping branch deletion${NC}"
            fi
        else
            execute_cmd "git branch -d $MERGED_BRANCHES" "Deleting merged branches"
        fi
    else
        echo -e "${GREEN}‚úì No merged branches to clean${NC}"
    fi
    echo
fi

# Clean remote tracking branches
if [ "$CLEAN_REMOTES" = true ]; then
    echo -e "${BLUE}üåê Cleaning remote tracking branches...${NC}"
    execute_cmd "git remote prune origin" "Pruning remote tracking branches"
    echo
fi

# Clean stash entries
if [ "$CLEAN_STASH" = true ]; then
    echo -e "${BLUE}üì¶ Cleaning stash entries...${NC}"
    
    STASH_COUNT=$(git stash list | wc -l)
    if [ "$STASH_COUNT" -gt 0 ]; then
        echo -e "${YELLOW}Found $STASH_COUNT stash entries${NC}"
        git stash list
        
        if [ "$INTERACTIVE" = true ] && [ "$DRY_RUN" = false ]; then
            read -p "Clear all stash entries? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                execute_cmd "git stash clear" "Clearing all stash entries"
            else
                echo -e "${YELLOW}Keeping stash entries${NC}"
            fi
        else
            execute_cmd "git stash clear" "Clearing all stash entries"
        fi
    else
        echo -e "${GREEN}‚úì No stash entries to clean${NC}"
    fi
    echo
fi

# Clean old tags
if [ "$CLEAN_TAGS" = true ]; then
    echo -e "${BLUE}üè∑Ô∏è  Managing tags...${NC}"
    
    TAG_COUNT=$(git tag | wc -l)
    if [ "$TAG_COUNT" -gt 0 ]; then
        echo -e "${YELLOW}Found $TAG_COUNT tags${NC}"
        if [ "$TAG_COUNT" -gt 20 ]; then
            echo -e "${YELLOW}Showing last 10 tags:${NC}"
            git tag --sort=-version:refname | head -10
            echo "..."
        else
            git tag --sort=-version:refname
        fi
        
        if [ "$INTERACTIVE" = true ] && [ "$DRY_RUN" = false ]; then
            echo -e "${YELLOW}Manual tag cleanup required - showing tag list${NC}"
            echo -e "${BLUE}Use: git tag -d <tag_name> to delete specific tags${NC}"
        fi
    else
        echo -e "${GREEN}‚úì No tags found${NC}"
    fi
    echo
fi

# Optimize repository
if [ "$OPTIMIZE_REPO" = true ]; then
    echo -e "${BLUE}‚ö° Optimizing repository...${NC}"
    
    # Get repo size before optimization
    if command -v du >/dev/null 2>&1; then
        REPO_SIZE_BEFORE=$(du -sh .git 2>/dev/null | cut -f1 || echo "unknown")
        echo -e "${BLUE}Repository size before optimization: $REPO_SIZE_BEFORE${NC}"
    fi
    
    execute_cmd "git gc --aggressive --prune=now" "Running garbage collection"
    execute_cmd "git repack -ad" "Repacking objects"
    execute_cmd "git prune" "Pruning unreachable objects"
    
    # Get repo size after optimization
    if command -v du >/dev/null 2>&1; then
        REPO_SIZE_AFTER=$(du -sh .git 2>/dev/null | cut -f1 || echo "unknown")
        echo -e "${GREEN}Repository size after optimization: $REPO_SIZE_AFTER${NC}"
    fi
    echo
fi

# Summary
echo -e "${GREEN}üéâ Git cleanup completed!${NC}"
echo
echo -e "${BLUE}üí° Additional tips:${NC}"
echo -e "  ‚Ä¢ Use ${YELLOW}git log --oneline --graph${NC} to visualize history"
echo -e "  ‚Ä¢ Use ${YELLOW}git remote prune origin${NC} to clean remote branches regularly"
echo -e "  ‚Ä¢ Consider setting up ${YELLOW}git hooks${NC} for automated cleanup"
echo -e "  ‚Ä¢ Use ${YELLOW}git reflog expire --expire=90.days.ago --all${NC} for deep cleanup"
